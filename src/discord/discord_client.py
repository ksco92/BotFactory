"""Client for discord operations."""

import json
from typing import Self

import requests
from nacl.signing import VerifyKey

from utils.secrets_manager_client import SecretsManagerClient


class DiscordClient:
    """Client for discord operations."""

    def __init__(self: Self, secret_name: str) -> None:
        """
        Client for discord operations.

        :param secret_name: Name of the secret there the API token is.
        """
        secrets_manager_client = SecretsManagerClient()
        self._api_url = "https://discord.com/api"
        self._secret = secrets_manager_client.get_secret(secret_name)
        self._headers = {"Authorization": f'Bot {self._secret["Token"]}'}
        self.response_types = {
            "PONG": 1,
            "ACK_NO_SOURCE": 2,
            "MESSAGE_NO_SOURCE": 3,
            "CHANNEL_MESSAGE_WITH_SOURCE": 4,
            "ACK_WITH_SOURCE": 5,
        }

    def get_success_response(
        self: Self,
        content: str | None,
        ping: bool = False,
    ) -> dict:
        """
        Get a success response to send back to Discord.

        :param content: Content to send.
        :param ping: If true, send a pong response.
        :return: A dictionary with the response.
        """
        if not ping:
            return {
                "isBase64Encoded": False,
                "statusCode": 200,
                "body": json.dumps(
                    {
                        "type": self.response_types["CHANNEL_MESSAGE_WITH_SOURCE"],
                        "data": {
                            "content": content,
                        },
                    },
                ),
            }

        else:
            return {
                "isBase64Encoded": False,
                "statusCode": 200,
                "body": json.dumps(
                    {
                        "type": self.response_types["PONG"],
                    },
                ),
            }

    def get_unauthorized_response(self: Self, content: str) -> dict:
        """
        Get a response to send back to Discord when the request is unauthorized.

        :param content: Content to send.
        :return: A dictionary with the response.
        """
        return {
            "isBase64Encoded": False,
            "statusCode": 401,
            "body": json.dumps(
                {
                    "type": self.response_types["MESSAGE_NO_SOURCE"],
                    "data": {
                        "content": f"[UNAUTHORIZED]: {content}",
                    },
                },
            ),
        }

    def get_error_response(self: Self, content: str) -> dict:
        """
        Get a response to send back to Discord when an error occurs.

        :param content: Content to send.
        :return: A dictionary with the response.
        """
        return {
            "isBase64Encoded": False,
            "statusCode": 500,
            "body": json.dumps(
                {
                    "type": self.response_types["MESSAGE_NO_SOURCE"],
                    "data": {
                        "content": f"[ERROR]: {content}",
                    },
                },
            ),
        }

    def verify_event_signature(self: Self, event: dict) -> bool:
        """
        Verify the signature of an event sent by Discord.

        :param event: AWS event generated by Discord.
        :return: True if the signature is valid.
        """
        public_key = self._secret["PublicKey"]

        raw_body = event.get("body")
        auth_sig = event["headers"].get("x-signature-ed25519")
        auth_ts = event["headers"].get("x-signature-timestamp")

        verify_key = VerifyKey(bytes.fromhex(public_key))

        verify_key.verify(f"{auth_ts}{raw_body}".encode(), bytes.fromhex(auth_sig))

        return True

    def get_user(self: Self, user_id: str) -> str:
        """
        Get the username and discriminator of a user.

        :param user_id: ID of the user.
        :raises RuntimeError: If the user could not be retrieved.
        :return: Username and discriminator of the user.
        """
        url = f"{self._api_url}/users/{user_id}"

        response = requests.get(url, headers=self._headers)

        if response.status_code == 200:
            response_content = json.loads(response.content)
            return f'{response_content["username"]}#{response_content["discriminator"]}'

        else:
            raise RuntimeError(
                f"""Unable to get user {user_id} -> {str(json.loads(response.content))}""",
            )

    @staticmethod
    def get_event_attributes(event: dict) -> dict:
        """
        Parse important details of a Discord event.

        :param event: AWS event generated by discord.
        :return: Details of the Discord event.
        """
        discord_event = json.loads(event["body"])
        is_ping = True if discord_event.get("type") == 1 else False

        if is_ping:
            return {
                "is_ping": is_ping,
            }

        user_name = discord_event["member"]["user"]["username"]
        discriminator = discord_event["member"]["user"]["discriminator"]
        user_id = discord_event["member"]["user"]["id"]
        command_issuer = f"{user_name}#{discriminator}"
        channel_id = discord_event["channel_id"]

        return {
            "discord_event": discord_event,
            "command": discord_event["data"]["name"],
            "options": discord_event["data"].get("options"),
            "command_issuer": command_issuer,
            "command_issuer_id": user_id,
            "channel_id": channel_id,
        }

    def send_message_to_channel(self: Self, content: dict, channel_id: str) -> bool:
        """
        Send a message to a channel.

        :param content: Content to send.
        :param channel_id: ID of the channel.
        :raises Exception: If the message was not sent successfully.
        :return: True if the message was sent successfully.
        """
        url = f"{self._api_url}/channels/{channel_id}/messages"

        response = requests.post(url, headers=self._headers, json=content)

        if response.status_code != 200:
            raise Exception(
                f"Failed to send message to channel {channel_id}: {str(response.content)}",
            )

        return True
